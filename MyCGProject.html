<!doctype html>
<html>

<head>
    <!--per ricaricare sempre la pagina da zero e non usare la cache-->
    <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
    <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
    <!--per definire la dimensione e posizione dell'elemento canvas;
        se i valori di width ed height inpostati qui sono superiori a
        corrispondenti settati in <canvas width= .. height=.. l'immagine
        verra' adattata ingrandendola, mentre se i valori sono inferiori,
        l'immagine verra' adattata rimpicciolendola
      -->
    <!-- 
      <body>         
          <style type="text/css">
             canvas { border: 2px solid blue; }
          </style>
      </body>
-->
    <style>
        body {
            background: #dddddd;
        }

        #my_Canvas {
            margin: 10px;
            padding: 10px;
            background: #ffffff;
            border: thin inset #aaaaaa;
        }

        .container {
            /*to manage text on canvas and webgl */
            position: relative;
        }

        #text {
            /*to manage text on canvas and webgl */
            background-color: transparent;
            /* needed because we setcanvas bg color to white */
            position: absolute;
            left: 100px;
            top: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <p> </p>
    <button id="Button1">Increase D</button>
    <button id="Button2">Decrease D</button>
    <button id="Button3">Increase Zm</button>
    <button id="Button4">Decrease Zm</button>
    <button id="Button5">Increase fov</button>
    <button id="Button6">Decrease fov</button>
    <p> </p>

    <div class="container">
        <canvas width="600" height="600" id="my_Canvas"></canvas>
        <!-- to manage text on canvas and webgl -->
        <canvas width="600" height="150" id="text"></canvas>

        <script id="vertex-shader" type="not-javascript">
            attribute vec3 position;
            uniform mat4 Pmatrix; 
            uniform mat4 Vmatrix;
            uniform mat4 Mmatrix;
            attribute vec3 color;//the color of the point 
            varying vec3 vColor;
            void main(void) { //pre-built function
              gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
              vColor=color;
            }
            </script>

        <script id="fragment-shader" type="not-javascript">
            precision mediump float; 
            varying vec3 vColor;
            void main(void) {
              gl_FragColor = vec4(vColor, 1.);
            }
            </script>

        <!-- OBJ Links -->
        <!-- Libraries -->
        <script type="text/javascript" src="resources/subdiv.js"></script>
        <script type="text/javascript" src="resources/mesh_utils.js"></script>
        <script type="text/javascript" src="resources/webgl-utils.js"></script>
        <script type="text/javascript" src="resources/m4.js"></script>
        <script type="text/javascript" src="resources/glm_light.js"></script>
        <script type="text/javascript" src="resources/jquery-3.5.1.js"></script>
        <script type="text/javascript" src="resources/objects_manager.js"></script>
        <script>

            function drawObject(objects, object_name) {
                var vertices = getVertices(objects, object_name);
                var indices = getIndices(objects, object_name);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    new Float32Array(vertices), gl.STATIC_DRAW);
                gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_position);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(indices), gl.STATIC_DRAW);

                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            }
            var mo_matrix, mo_matrix1;
            /*============= Creating a canvas ======================*/
            var canvas = document.getElementById('my_Canvas');
            gl = canvas.getContext('webgl');
            //to manage text on canvas and webgl
            // look up the text canvas.
            var textCanvas = document.getElementById("text");
            // make a 2D context for it
            var ctx = textCanvas.getContext("2d");

            /*============= Objects in scene =======================*/
            var objects = new Array();

            objects = addObject('Ferrari', './resources/data/cube.obj', objects);

            console.log(objects)

            var vertex_buffer = gl.createBuffer();
            var index_buffer = gl.createBuffer();


            //usa libreria webgl-utilis.js
            var shaderprogram = webglUtils.createProgramFromScripts(gl,
                ["vertex-shader", "fragment-shader"]);

            /*======== Associating attributes to vertex shader =====*/
            var _Pmatrix = gl.getUniformLocation(shaderprogram, "Pmatrix");
            var _Vmatrix = gl.getUniformLocation(shaderprogram, "Vmatrix");
            var _Mmatrix = gl.getUniformLocation(shaderprogram, "Mmatrix");
            var _position = gl.getAttribLocation(shaderprogram, "position");
            var _color = gl.getAttribLocation(shaderprogram, "color");

            gl.useProgram(shaderprogram);

            function degToRad(d) {
                return d * Math.PI / 180;
            }
            /*================= Mouse events ======================*/
            var mouseDown = function (e) {
                drag = true;
                old_x = e.pageX, old_y = e.pageY;
                e.preventDefault();
                return false;
            };

            var mouseUp = function (e) {
                drag = false;
            };

            var mouseMove = function (e) {
                if (!drag) return false;
                dX = -(e.pageX - old_x) * 2 * Math.PI / canvas.width;
                dY = -(e.pageY - old_y) * 2 * Math.PI / canvas.height;
                //console.log('stampa',dX,dY);
                THETA += dX;
                PHI += dY;
                old_x = e.pageX, old_y = e.pageY;
                e.preventDefault();
                render();
            };

            document.getElementById("Button1").onclick = function () { D *= 1.1 };
            document.getElementById("Button2").onclick = function () { D *= 0.9 };
            document.getElementById("Button3").onclick = function () { zmin *= 1.1; zmax *= 1.1 };
            document.getElementById("Button4").onclick = function () { zmin *= 0.9; zmax *= 0.9 };
            document.getElementById("Button5").onclick = function () { fov *= 1.1; fov *= 1.1 };
            document.getElementById("Button6").onclick = function () { fov *= 0.9; fov *= 0.9 };

            canvas.onmousedown = mouseDown;
            canvas.onmouseup = mouseUp;
            canvas.mouseout = mouseUp;
            canvas.onmousemove = mouseMove;
            //definizione parametri iniziali
            var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            var zmin = 1;
            var zmax = 100;
            var fov = 40;

            var THETA = degToRad(50), PHI = degToRad(30);
            var D = 120;

            var target = [0, 0, 0];
            var up = [0, 1, 0];

            var drag;
            var render = function () {
                //set projection matrix
                var proj_matrix = m4.perspective(degToRad(fov), aspect, zmin, zmax);
                //set view matrix
                var camera = [D * Math.sin(PHI) * Math.cos(THETA),
                D * Math.sin(PHI) * Math.sin(THETA),
                D * Math.cos(PHI)];
                var view_matrix = m4.inverse(m4.lookAt(camera, target, up));

                gl.enable(gl.DEPTH_TEST);
                // gl.depthFunc(gl.LEQUAL); 
                gl.clearColor(1.0, 1.0, 1.0, 1);
                /*to manage text on canvas and webgl */
                // Clear the 2D canvas
                //to manage text on canvas and webgl
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                gl.clearDepth(1.0);
                gl.viewport(0.0, 0.0, canvas.width, canvas.height);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.uniformMatrix4fv(_Pmatrix, false, proj_matrix);
                gl.uniformMatrix4fv(_Vmatrix, false, view_matrix);
                //set model matrix to I4
                mo_matrix = m4.identity();
                gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix);

                drawObject(objects, 'Ferrari');

                ctx.font = '18pt Calibri';
                ctx.fillStyle = 'green';
                ctx.fillText('Welcome to CAR Project', 90, 50);


            }
            const FRAMES_PER_SECOND = 30;  // Valid values are 60,30,20,15,10...
            // set the mim time to render the next frame
            const FRAME_MIN_TIME = (1000 / 60) * (60 / FRAMES_PER_SECOND) - (1000 / 60) * 0.5;
            var lastFrameTime = 0;  // the last frame time
            function update(time) {
                if (time - lastFrameTime < FRAME_MIN_TIME) { //skip the frame if the call is too early
                    window.requestAnimationFrame(update);
                    return; // return as there is nothing to do
                }
                lastFrameTime = time; // remember the time of the rendered frame
                // render the frame
                render();
                window.requestAnimationFrame(update); // get next frame
            }

            update(); // start animation
            window.requestAnimationFrame(update);  
        </script>
</body>

</html>