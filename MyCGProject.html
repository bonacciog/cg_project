<!doctype html>
<html>

<head>
    <!--per ricaricare sempre la pagina da zero e non usare la cache-->
    <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
    <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
    <!--per definire la dimensione e posizione dell'elemento canvas;
        se i valori di width ed height inpostati qui sono superiori a
        corrispondenti settati in <canvas width= .. height=.. l'immagine
        verra' adattata ingrandendola, mentre se i valori sono inferiori,
        l'immagine verra' adattata rimpicciolendola
      -->
    <!-- 
      <body>         
          <style type="text/css">
             canvas { border: 2px solid blue; }
          </style>
      </body>
-->
    <style>
        body {
            background: #dddddd;
        }

        #my_Canvas {
            margin: 10px;
            padding: 10px;
            background: #ffffff;
            border: thin inset #aaaaaa;
        }

        .container {
            /*to manage text on canvas and webgl */
            position: relative;
        }

        #text {
            /*to manage text on canvas and webgl */
            background-color: transparent;
            /* needed because we setcanvas bg color to white */
            position: absolute;
            left: 100px;
            top: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <p>
        <button id="camera">Change camera</button>
        <button id="reset">Reset game</button>
    </p>
    <p>
        <button id="Button1">Increase D</button>
        <button id="Button2">Decrease D</button>
        <button id="Button3">Increase Zm</button>
        <button id="Button4">Decrease Zm</button>
        <button id="Button5">Increase fov</button>
        <button id="Button6">Decrease fov</button>
    </p>

    <div class="container">
        <canvas width="600" height="600" id="my_Canvas"></canvas>
        <!-- to manage text on canvas and webgl -->
        <canvas width="600" height="150" id="text"></canvas>

        <script id="vertex-shader" type="not-javascript">
            attribute vec3 position;
            uniform mat4 Pmatrix; 
            uniform mat4 Vmatrix;
            uniform mat4 Mmatrix;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            void main(void) { //pre-built function
              gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
              v_texcoord = a_texcoord;
            }
            </script>

        <script id="fragment-shader" type="not-javascript">
            precision mediump float; 
            varying vec2 v_texcoord;

            // The texture.
            uniform sampler2D u_texture;

            void main(void) {
                gl_FragColor = texture2D(u_texture, v_texcoord);            }
            </script>

        <!-- OBJ Links -->
        <!-- Libraries -->
        <script type="text/javascript" src="resources/subdiv.js"></script>
        <script type="text/javascript" src="resources/mesh_utils.js"></script>
        <script type="text/javascript" src="resources/webgl-utils.js"></script>
        <script type="text/javascript" src="resources/m4.js"></script>
        <script type="text/javascript" src="resources/glm_light.js"></script>
        <script type="text/javascript" src="resources/jquery-3.5.1.js"></script>
        <script type="text/javascript" src="resources/objects_manager.js"></script>
        <script type="text/javascript" src="car1.js"></script>
        <script type="text/javascript" src="camera.js"></script>
        <script type="text/javascript" src="environment.js"></script>
        <script>

            /* function drawObjectFill(objects, object_name, r, g, b) {
                var current_object = getObjectByName(objects, object_name);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    new Float32Array(current_object.vertices), gl.STATIC_DRAW);
                gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_position);

                var colors = makeGivenVertexColors(current_object.vertices, r, g, b)
                gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    new Float32Array(colors), gl.STATIC_DRAW);
                gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_color);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(current_object.indices), gl.STATIC_DRAW);

                gl.drawElements(gl.TRIANGLES, current_object.indices.length, gl.UNSIGNED_SHORT, 0);
            } */

            function drawObjectFill(objects, object_name) {
                var current_object = getObjectByName(objects, object_name);
                var vertices=
    [
     0
, 0
, 0
, 1
, 1
, -1
, 1
, -1
, -1
, 1
, 1
, 1
, 1
, -1
, 1
, -1
, 1
, -1
, -1
, -1
, -1
, -1
, 1
, 1
, -1
, -1
, 1

    ];
                gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    new Float32Array(vertices), gl.STATIC_DRAW);
                gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_position);

                // Turn on the teccord attribute
                gl.enableVertexAttribArray(texcoordLocation);

                // Bind the position buffer.
                gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);

                // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)
                gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);

                // Tell the shader to use texture unit 0 for u_texture
                gl.uniform1i(textureLocation, 0);

                // Draw the geometry.
                gl.drawArrays(gl.TRIANGLES, 0, 6*6);
            }

            function setTexcoords(gl) {
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(
                        [
                         0
, 0
, 0.625
, 0.5
, 0.875
, 0.5
, 0.875
, 0.75
, 0.625
, 0.75
, 0.375
, 0.75
, 0.625
, 1
, 0.375
, 1
, 0.375
, 0
, 0.625
, 0
, 0.625
, 0.25
, 0.375
,0.25
, 0.125
, 0.5
, 0.375
, 0.5
, 0.125
, 0.75
                        ]

                    ),
                    gl.STATIC_DRAW);
            }

            function drawObjectWire(objects, object_name) {
                var current_object = getObjectByName(objects, object_name);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    new Float32Array(current_object.vertices), gl.STATIC_DRAW);
                gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_position);

                var colors = makeGivenVertexColors(current_object.vertices, 0, 0, 0)
                gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
                gl.bufferData(gl.ARRAY_BUFFER,
                    new Float32Array(colors), gl.STATIC_DRAW);
                gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_color);


                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, edge_buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(current_object.edges), gl.STATIC_DRAW);

                gl.drawElements(gl.LINES, current_object.edges.length, gl.UNSIGNED_SHORT, 0);
            }

            var mo_matrix, mo_matrix1;

            /*============= Creating a canvas ======================*/
            var canvas = document.getElementById('my_Canvas');
            var gl = canvas.getContext('webgl');
            //to manage text on canvas and webgl
            // look up the text canvas.
            var textCanvas = document.getElementById("text");
            // make a 2D context for it
            var ctx = textCanvas.getContext("2d");

            var objects;

            objects = new Array();
            addObject('chassis', './resources/data/chassis.obj', objects);
            addObject('ruota_posteriore', './resources/data/posteriore.obj', objects);
            addObject('ruota_anteriore', './resources/data/anteriore.obj', objects);
            addObject('parcheggio', './resources/data/ParkingLot.obj', objects);
            addObject('rettilineo', './resources/data/rettilineo.obj', objects);
            addObject('curva', './resources/data/curva.obj', objects);
            addObject('cono', './resources/data/cono.obj', objects);

            addObject('cube', './resources/data/cube.obj', objects);
            console.log(objects)

            /*================ PIANO SU CUI GIACE L'AUTO ==================*/
            const S = 1000; // size
            const H = -2; // altezza
            var vertices3 = [-S, H, -S, S, H, -S, S, H, S, -S, H, S,];
            var colors3 = [0, 0.7, 0, 0, 0.7, 0, 0, 0.7, 0, 0, 0.7, 0];
            var indices3 = [0, 1, 2, 0, 2, 3,];

            var vertex_buffer3 = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer3);
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(vertices3), gl.STATIC_DRAW);
            // Create and store data into color buffer 
            var color_buffer3 = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer3);
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array(colors3), gl.STATIC_DRAW);
            // Create and store data into index buffer
            var index_buffer3 = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer3);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices3), gl.STATIC_DRAW);

            function drawFloor() {
                gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer3);
                gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_position);

                gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer3);
                gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(_color);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer3);
                gl.drawElements(gl.TRIANGLES, indices3.length, gl.UNSIGNED_SHORT, 0);
            }
            /*================================================================*/



            var vertex_buffer = gl.createBuffer();
            var index_buffer = gl.createBuffer();
            var color_buffer = gl.createBuffer();
            var edge_buffer = gl.createBuffer();
            /*=============== TEXTURE =========================*/
            var texcoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
            // Set Texcoords.
            setTexcoords(gl);

            // Create a texture.
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            // Fill the texture with a 1x1 blue pixel.
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                new Uint8Array([0, 0, 255, 255]));
            // Asynchronously load an image
            var image = new Image();
            image.src = "resources/images/strada.jpg";
            image.addEventListener('load', function () {
                // Now that the image has loaded make copy it to the texture.
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                // Check if the image is a power of 2 in both dimensions.
                if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                    // Yes, it's a power of 2. Generate mips.
                    gl.generateMipmap(gl.TEXTURE_2D);
                    console.log('mipmap');
                } else {
                    // No, it's not a power of 2. Turn of mips and set wrapping to clamp to edge
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
            });

            function isPowerOf2(value) {
                return (value & (value - 1)) === 0;
            }


            //usa libreria webgl-utilis.js
            var shaderprogram = webglUtils.createProgramFromScripts(gl,
                ["vertex-shader", "fragment-shader"]);

            /*======== Associating attributes to vertex shader =====*/
            var _Pmatrix = gl.getUniformLocation(shaderprogram, "Pmatrix");
            var _Vmatrix = gl.getUniformLocation(shaderprogram, "Vmatrix");
            var _Mmatrix = gl.getUniformLocation(shaderprogram, "Mmatrix");
            var _position = gl.getAttribLocation(shaderprogram, "position");
            var texcoordLocation = gl.getAttribLocation(shaderprogram, "a_texcoord");
            var textureLocation = gl.getUniformLocation(shaderprogram, "u_texture");

            gl.useProgram(shaderprogram);

            function degToRad(d) {
                return d * Math.PI / 180;
            }


            /*================= Mouse events ======================*/
            var mouseDown = function (e) {
                drag = true;
                old_x = e.pageX, old_y = e.pageY;
                e.preventDefault();
                return false;
            };

            var mouseUp = function (e) {
                drag = false;
            };

            var mouseMove = function (e) {
                if (!drag) return false;
                dX = -(e.pageX - old_x) * 2 * Math.PI / canvas.width;
                dY = -(e.pageY - old_y) * 2 * Math.PI / canvas.height;
                THETA += dX;
                PHI += dY;
                old_x = e.pageX, old_y = e.pageY;
                e.preventDefault();
                render();
            };

            document.getElementById("camera").onclick = function () {
                var cameras = Object.keys(setCamera);
                var camera_index = cameras.indexOf(camera_type);
                if (camera_index == cameras.length - 1)
                    camera_type = cameras[0];
                else
                    camera_type = cameras[camera_index + 1];

            };

            document.getElementById("reset").onclick = function () {
                ResetScene();
                window.addEventListener('keydown', doKeyDown, true);
                window.addEventListener('keyup', doKeyUp, true);
            };
            document.getElementById("Button1").onclick = function () { D *= 1.1 };
            document.getElementById("Button2").onclick = function () { D *= 0.9 };
            document.getElementById("Button3").onclick = function () { zmin *= 1.1; zmax *= 1.1 };
            document.getElementById("Button4").onclick = function () { zmin *= 0.9; zmax *= 0.9 };
            document.getElementById("Button5").onclick = function () { fov *= 1.1; fov *= 1.1 };
            document.getElementById("Button6").onclick = function () { fov *= 0.9; fov *= 0.9 };

            canvas.onmousedown = mouseDown;
            canvas.onmouseup = mouseUp;
            canvas.mouseout = mouseUp;
            canvas.onmousemove = mouseMove;
            window.addEventListener('keydown', doKeyDown, true);
            window.addEventListener('keyup', doKeyUp, true);
            /*=================== Drawing =================== */

            function doKeyDown(e) {
                //====================
                // THE W KEY
                //====================
                if (e.keyCode == 87) key[0] = true;
                //====================
                // THE S KEY
                //====================
                if (e.keyCode == 83) key[2] = true;
                //====================
                // THE A KEY
                //====================
                if (e.keyCode == 65) key[1] = true;
                //====================
                // THE D KEY
                //====================
                if (e.keyCode == 68) key[3] = true;

                //====================
                // THE UP KEY
                //====================
                if (e.keyCode == 101) keyCamera[0] = true;
                //====================
                // THE DOWN KEY
                //====================
                if (e.keyCode == 98) keyCamera[2] = true;
                //====================
                // THE LEFT KEY
                //====================
                if (e.keyCode == 97) keyCamera[1] = true;
                //====================
                // THE RIGHT KEY
                //====================
                if (e.keyCode == 99) keyCamera[3] = true;
            }
            function doKeyUp(e) {
                //====================
                // THE W KEY
                //====================
                if (e.keyCode == 87) key[0] = false;
                //====================
                // THE S KEY
                //====================
                if (e.keyCode == 83) key[2] = false;
                //====================
                // THE A KEY
                //====================
                if (e.keyCode == 65) key[1] = false;
                //====================
                // THE D KEY
                //====================
                if (e.keyCode == 68) key[3] = false;

                //====================
                // THE UP KEY
                //====================
                if (e.keyCode == 101) keyCamera[0] = false;
                //====================
                // THE DOWN KEY
                //====================
                if (e.keyCode == 98) keyCamera[2] = false;
                //====================
                // THE LEFT KEY
                //====================
                if (e.keyCode == 97) keyCamera[1] = false;
                //====================
                // THE RIGHT KEY
                //====================
                if (e.keyCode == 99) keyCamera[3] = false;
            }

            //definizione parametri iniziali
            var aspect, zmin, zmax, fov;

            var THETA, PHI, D;
            var target;
            var up = [0, 1, 0];

            var drag;
            var camera, dst, cameraMatrix, camera_type;
            var end;

            var ResetScene = function () {

                aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                zmin = 1;
                zmax = 140;
                fov = 40;

                THETA = degToRad(0), PHI = degToRad(90); // per ottenere 0,4,0 90 90 4
                D = 0.125; //

                target = [0, 0, -4];

                end = false;


                camera = [D * Math.sin(PHI) * Math.cos(THETA),
                D * Math.sin(PHI) * Math.sin(THETA),
                D * Math.cos(PHI)];

                dst = m4.subtractVectors(target, camera, dst)

                cameraMatrix = m4.lookAt(camera, target, up);

                camera_type = 'default';

                initDebugCamera();
                CarInit();

                initBounds();
            }

            var render = async function () {
                //console.log(px,pz)
                if (true/* checkEnvironmentLimit(px, pz) */ && !end) {
                    updateCheckpoint(px, pz);
                    //set projection matrix
                    var proj_matrix = m4.perspective(degToRad(fov), aspect, zmin, zmax);
                    //set view matrix
                    setCamera[camera_type]();
                    var view_matrix = m4.inverse(cameraMatrix);

                    gl.enable(gl.DEPTH_TEST);
                    // gl.depthFunc(gl.LEQUAL); 
                    gl.clearColor(1.0, 1.0, 1.0, 1);
                    /*to manage text on canvas and webgl */
                    // Clear the 2D canvas
                    //to manage text on canvas and webgl
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                    gl.clearDepth(1.0);
                    gl.viewport(0.0, 0.0, canvas.width, canvas.height);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.uniformMatrix4fv(_Pmatrix, false, proj_matrix);
                    gl.uniformMatrix4fv(_Vmatrix, false, view_matrix);
                    //set model matrix to I4

                    mo_matrix = m4.identity();

                    gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix);

                    drawObjectFill(objects, 'cube');
                    //drawFloor();

                    /* mo_matrix = m4.identity();



                    gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix);


 */
                    /*  CarRender();
 
                     RoadRender(); */

                }
                else {
                    //console.log(px,pz);
                    end = true;
                    window.removeEventListener('keydown', doKeyDown, true);
                    window.removeEventListener('keyup', doKeyUp, true);
                    ctx.font = '40pt Calibri';
                    ctx.fillStyle = 'red';
                    ctx.fillText('GAME OVER', 90, 100);
                }
            }
            const FRAMES_PER_SECOND = 30;  // Valid values are 60,30,20,15,10...
            // set the mim time to render the next frame
            const FRAME_MIN_TIME = (1000 / 60) * (60 / FRAMES_PER_SECOND) - (1000 / 60) * 0.5;
            var lastFrameTime = 0;  // the last frame time
            function update(time) {
                if (time - lastFrameTime < FRAME_MIN_TIME) { //skip the frame if the call is too early
                    CarDoStep();
                    window.requestAnimationFrame(update);
                    return; // return as there is nothing to do
                }
                lastFrameTime = time; // remember the time of the rendered frame
                // render the frame
                render();
                window.requestAnimationFrame(update); // get next frame
            }
            ResetScene();
            update(); // start animation
            window.requestAnimationFrame(update);  
        </script>
</body>

</html>