<!doctype html>
<html>

<head>
    <!--per ricaricare sempre la pagina da zero e non usare la cache-->
    <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
    <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
    <!--per definire la dimensione e posizione dell'elemento canvas;
        se i valori di width ed height inpostati qui sono superiori a
        corrispondenti settati in <canvas width= .. height=.. l'immagine
        verra' adattata ingrandendola, mentre se i valori sono inferiori,
        l'immagine verra' adattata rimpicciolendola-->
    <style>
        body {
            background: #dddddd;
        }

        #my_Canvas {
            margin: 10px;
            padding: 10px;
            background: #ffffff;
            border: thin inset #aaaaaa;
        }

        .container {
            /*to manage text on canvas and webgl */
            position: relative;
        }

        #text {
            /*to manage text on canvas and webgl */
            background-color: transparent;
            /* needed because we setcanvas bg color to white */
            position: absolute;
            left: 100px;
            top: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>

    <p> </p>
    <button id="Button1">Increase D</button>
    <button id="Button2">Decrease D</button>
    <button id="Button3">Increase Zm</button>
    <button id="Button4">Decrease Zm</button>
    <button id="Button5">Increase fov</button>
    <button id="Button6">Decrease fov</button>
    <p> </p>

    <div class="container">
        <canvas width="500" height="500" id="my_Canvas"></canvas>
        <!-- to manage text on canvas and webgl -->
        <canvas width="500" height="150" id="text"></canvas>
    </div>

    <script id="vertex-shader" type="not-javascript">
attribute vec3 position;
uniform mat4 Pmatrix; 
uniform mat4 Vmatrix;
uniform mat4 Mmatrix;
attribute vec3 color;//the color of the point 
varying vec3 vColor;
void main(void) { //pre-built function
  gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
  vColor=color;
}
</script>

    <script id="fragment-shader" type="not-javascript">
precision mediump float; 
varying vec3 vColor;
void main(void) {
  gl_FragColor = vec4(vColor, 1.);
}
</script>

    <script type="text/javascript" src="resources/webgl-utils.js"></script>
    <script type="text/javascript" src="resources/m4.js"></script>
    <script>

        // disegna un cubo a facce triangolari
        function drawCubeFill() {
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
            gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_position);

            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
            gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_color);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        // disegna un cubo in wireframe
        function drawCubeWire() {
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer2);
            gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_position);

            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer2);
            gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_color);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer2);
            gl.drawElements(gl.LINES, indices2.length, gl.UNSIGNED_SHORT, 0);
        }

        function drawCube() {
            drawCubeFill();
            drawCubeWire();
        }

        // disegna carlinga composta da 1 cubo traslato e scalato
        function drawCarlinga(model_matrix) {
            // vado al frame pezzo_A
            mo_matrix1 = m4.copy(model_matrix);
            mo_matrix1 = m4.scale(mo_matrix1, 0.25, 0.14, 1);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();

            // // disegna altri 3 cubi traslati escalati per carlinga
            // // scommentare
            //   mo_matrix1=m4.copy(model_matrix);
            //   // vado frame pezzo_B
            //   mo_matrix1=m4.translate(mo_matrix1,0,-0.11,-0.95);
            //   mo_matrix1=m4.scale(mo_matrix1,0.6, 0.05, 0.15);
            //   gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            //   drawCube();

            //   mo_matrix1=m4.copy(model_matrix);
            //   // vado frame pezzo_C
            //   mo_matrix1=m4.translate(mo_matrix1,0,-0.11,0);
            //   mo_matrix1=m4.scale(mo_matrix1,0.6, 0.05, 0.3);
            //   gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            //   drawCube();

            //   mo_matrix1=m4.copy(model_matrix);
            //   // vado frame pezzo_D
            //   mo_matrix1=m4.xRotate(mo_matrix1, degToRad(-5));
            //   mo_matrix1=m4.translate(mo_matrix1,0,+0.2,+0.95);
            //   mo_matrix1=m4.scale(mo_matrix1,0.6, 0.05, 0.3);
            //   gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            //   drawCube();
        }

        // disegna  macchina con le ruote
        function drawCar(mozzo) {

            // disegna corpo macchina
            drawCarlinga(mo_matrix);

            mo_matrix1 = m4.copy(mo_matrix);
            // // ruota posteriore D
            mo_matrix1 = m4.translate(mo_matrix1, 0.58, -0.05, 0.8);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo);
            mo_matrix1 = m4.scale(mo_matrix1, 0.1, 0.20, 0.20);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();

            mo_matrix1 = m4.copy(mo_matrix);
            // // per rendere la ruota posteriore D a stella (più simile a una ruota)
            // // ne creo un'altra ruotata di 90 gradi
            mo_matrix1 = m4.translate(mo_matrix1, 0.58, -0.05, 0.8);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo + degToRad(45));
            mo_matrix1 = m4.scale(mo_matrix1, 0.1, 0.20, 0.20);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();

            // // drawAxis(); // disegna assi frame ruota posteriore D

            mo_matrix1 = m4.copy(mo_matrix);
            // // ruota posteriore S
            mo_matrix1 = m4.translate(mo_matrix1, -0.58, -0.05, +0.8);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo);
            mo_matrix1 = m4.scale(mo_matrix1, 0.1, 0.20, 0.20);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();
            // // drawAxis(); // disegna assi frame ruota posteriore S

            mo_matrix1 = m4.copy(mo_matrix);
            // // per rendere la ruota posteriore S a stella (più simile a una ruota)
            // // ne creo un'altra ruotata di 90 gradi
            mo_matrix1 = m4.translate(mo_matrix1, -0.58, -0.05, +0.8);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo + degToRad(45));
            mo_matrix1 = m4.scale(mo_matrix1, 0.1, 0.20, 0.20);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();

            mo_matrix1 = m4.copy(mo_matrix);
            // ruota anteriore D
            mo_matrix1 = m4.translate(mo_matrix1, 0.58, -0.05, -0.55);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo);
            mo_matrix1 = m4.scale(mo_matrix1, 0.08, 0.15, 0.15);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();
            // // drawAxis(); // disegna assi frame ruota anteriore D

            mo_matrix1 = m4.copy(mo_matrix);
            // // per rendere la ruota posteriore D a stella (più simile a una ruota)
            // // ne creo un'altra ruotata di 90 gradi
            mo_matrix1 = m4.translate(mo_matrix1, 0.58, -0.05, -0.55);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo + degToRad(45));
            mo_matrix1 = m4.scale(mo_matrix1, 0.08, 0.15, 0.15);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();

            mo_matrix1 = m4.copy(mo_matrix);
            // ruota anteriore S
            mo_matrix1 = m4.translate(mo_matrix1, -0.58, -0.05, -0.55);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo);
            mo_matrix1 = m4.scale(mo_matrix1, 0.08, 0.15, 0.15);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();
            // drawAxis(); // disegna assi frame ruota anteriore S

            mo_matrix1 = m4.copy(mo_matrix);
            // // per rendere la ruota posteriore S a stella (più simile a una ruota)
            // // ne creo un'altra ruotata di 90 gradi
            mo_matrix1 = m4.translate(mo_matrix1, -0.58, -0.05, -0.55);
            mo_matrix1 = m4.xRotate(mo_matrix1, mozzo + degToRad(45));
            mo_matrix1 = m4.scale(mo_matrix1, 0.08, 0.15, 0.15);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix1);
            drawCube();
        }


        /*============= Creating a canvas ======================*/
        var canvas = document.getElementById('my_Canvas');
        gl = canvas.getContext('webgl');
        //to manage text on canvas and webgl
        // look up the text canvas.
        var textCanvas = document.getElementById("text");
        // make a 2D context for it
        var ctx = textCanvas.getContext("2d");

        /*========== Defining and storing the geometry ==========*/
        var vertices = [
            -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1,
            -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,
            -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1,
            1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1,
            -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1,
            -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,];

        var colors = [
            1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
            1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
            1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
            1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
            1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
            1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
        ];
        var indices = [
            0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14,
            12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];

        var vertices2 = [
            -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1,];
        var colors2 = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var indices2 = [
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 1, 5, 2, 6, 3, 7, 0, 4];

        // Create and store data into vertex buffer 
        var vertex_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(vertices), gl.STATIC_DRAW);
        // Create and store data into color buffer 
        var color_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(colors), gl.STATIC_DRAW);
        // Create and store data into index buffer
        var index_buffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        var vertex_buffer2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer2);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(vertices2), gl.STATIC_DRAW);
        // Create and store data into color buffer 
        var color_buffer2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer2);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(colors2), gl.STATIC_DRAW);
        // Create and store data into index buffer
        var index_buffer2 = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer2);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices2), gl.STATIC_DRAW);

        //usa libreria webgl-utilis.js
        var shaderprogram = webglUtils.createProgramFromScripts(gl,
            ["vertex-shader", "fragment-shader"]);

        /*======== Associating attributes to vertex shader =====*/
        var _Pmatrix = gl.getUniformLocation(shaderprogram, "Pmatrix");
        var _Vmatrix = gl.getUniformLocation(shaderprogram, "Vmatrix");
        var _Mmatrix = gl.getUniformLocation(shaderprogram, "Mmatrix");
        var _position = gl.getAttribLocation(shaderprogram, "position");
        var _color = gl.getAttribLocation(shaderprogram, "color");

        gl.useProgram(shaderprogram);

        function degToRad(d) {
            return d * Math.PI / 180;
        }

        //definizione parametri iniziali
        var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        var zmin = 1;
        var zmax = 100;
        var fov = 40;

        var THETA = degToRad(50), PHI = degToRad(30);
        var D = 7;

        var target = [0, 0, 0];
        var up = [0, 1, 0];

        var drag;
        var mo_matrix, mo_matrix1;

        var mozzo_step = degToRad(15);
        var mozzo = 0;

        /*================= Mouse events ======================*/
        var mouseDown = function (e) {
            drag = true;
            old_x = e.pageX, old_y = e.pageY;
            e.preventDefault();
            return false;
        };

        var mouseUp = function (e) {
            drag = false;
        };

        var mouseMove = function (e) {
            if (!drag) return false;
            dX = -(e.pageX - old_x) * 2 * Math.PI / canvas.width;
            dY = -(e.pageY - old_y) * 2 * Math.PI / canvas.height;
            //console.log('stampa',dX,dY);
            THETA += dX;
            PHI += dY;
            old_x = e.pageX, old_y = e.pageY;
            e.preventDefault();
            render();
        };

        //da usarsi senza animazione
        // document.getElementById("Button1").onclick = function(){D *= 1.1; render()};
        // document.getElementById("Button2").onclick = function(){D *= 0.9; render()};
        // document.getElementById("Button3").onclick = function(){zmin  *= 1.1; zmax *= 1.1; render()};
        // document.getElementById("Button4").onclick = function(){zmin *= 0.9; zmax *= 0.9; render()};
        // document.getElementById("Button5").onclick = function(){fov  *= 1.1; fov *= 1.1; render()};
        // document.getElementById("Button6").onclick = function(){fov *= 0.9; fov *= 0.9; render()};

        document.getElementById("Button1").onclick = function () { D *= 1.1 };
        document.getElementById("Button2").onclick = function () { D *= 0.9 };
        document.getElementById("Button3").onclick = function () { zmin *= 1.1; zmax *= 1.1 };
        document.getElementById("Button4").onclick = function () { zmin *= 0.9; zmax *= 0.9 };
        document.getElementById("Button5").onclick = function () { fov *= 1.1; fov *= 1.1 };
        document.getElementById("Button6").onclick = function () { fov *= 0.9; fov *= 0.9 };

        canvas.onmousedown = mouseDown;
        canvas.onmouseup = mouseUp;
        canvas.mouseout = mouseUp;
        canvas.onmousemove = mouseMove;

        /*=================== Drawing =================== */
        var render = function () {
            //set projection matrix
            var proj_matrix = m4.perspective(degToRad(fov), aspect, zmin, zmax);
            //set view matrix
            var camera = [D * Math.sin(PHI) * Math.cos(THETA),
            D * Math.sin(PHI) * Math.sin(THETA),
            D * Math.cos(PHI)];
            var view_matrix = m4.inverse(m4.lookAt(camera, target, up));
            //set model matrix to I4

            gl.enable(gl.DEPTH_TEST);
            // gl.depthFunc(gl.LEQUAL); 
            gl.clearColor(1.0, 1.0, 1.0, 1);
            /*to manage text on canvas and webgl */
            // Clear the 2D canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniformMatrix4fv(_Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(_Vmatrix, false, view_matrix);
            mo_matrix = m4.identity();
            //gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix);

            //drawAxis(); // disegna assi frame OGGETTO
            //disegna il cubo base anziche' la macchina
            //drawCubeWire();
            if (!drag)
                mozzo -= mozzo_step;

            drawCar(mozzo);

            /*to manage text on canvas and webgl */
            ctx.font = '18pt Calibri';
            ctx.fillStyle = 'green';
            ctx.fillText('Welcome to CAR Project', 40, 50);

            // window.requestAnimationFrame(render); 
        }
        // render();

        //Per fare una prova di animazione senza andare a tempo, commentare quanto segue
        //e scommentare le:
        //window.requestAnimationFrame(render);
        //
        //render()
        //
        const FRAMES_PER_SECOND = 30;  // Valid values are 60,30,20,15,10...
        // set the mim time to render the next frame
        const FRAME_MIN_TIME = (1000 / 60) * (60 / FRAMES_PER_SECOND) - (1000 / 60) * 0.5;
        var lastFrameTime = 0;  // the last frame time
        function update(time) {
            if (time - lastFrameTime < FRAME_MIN_TIME) { //skip the frame if the call is too early
                requestAnimationFrame(update);
                return; // return as there is nothing to do
            }
            lastFrameTime = time; // remember the time of the rendered frame
            // render the frame
            render();
            requestAnimationFrame(update); // get next frame
        }
        requestAnimationFrame(update); // start animation

    </script>
</body>

</html>