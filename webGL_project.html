<!doctype html>
<html>

<head>
    <!--per ricaricare sempre la pagina da zero e non usare la cache-->
    <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
    <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
    <!--per definire la dimensione e posizione dell'elemento canvas;
        se i valori di width ed height inpostati qui sono superiori a
        corrispondenti settati in <canvas width= .. height=.. l'immagine
        verra' adattata ingrandendola, mentre se i valori sono inferiori,
        l'immagine verra' adattata rimpicciolendola
      -->
    <!-- 
      <body>         
          <style type="text/css">
             canvas { border: 2px solid blue; }
          </style>
      </body>
-->
    <style>
        body {
            background: #dddddd;
        }

        #my_Canvas {
            margin: 10px;
            padding: 10px;
            background: #ffffff;
            border: thin inset #aaaaaa;
        }

        .container {
            /*to manage text on canvas and webgl */
            position: relative;
        }

        #text {
            /*to manage text on canvas and webgl */
            background-color: transparent;
            /* needed because we setcanvas bg color to white */
            position: absolute;
            left: 100px;
            top: 10px;
            z-index: 10;
        }
    </style>
</head>

<body>
    <p> </p>
    <!--    <button id = "Button1">Increase D</button>
    <button id = "Button2">Decrease D</button>
    <button id = "Button3">Increase Zm</button>
    <button id = "Button4">Decrease Zm</button>
    <button id = "Button5">Increase fov</button>
    <button id = "Button6">Decrease fov</button> -->
    <p> </p>

    <div class="container">
        <canvas width="600" height="600" id="my_Canvas"></canvas>
        <!-- to manage text on canvas and webgl -->
        <canvas width="600" height="150" id="text"></canvas>

    </div>

    <script id="vertex-shader" type="not-javascript">
        attribute vec3 position;
        uniform mat4 Pmatrix; 
        uniform mat4 Vmatrix;
        uniform mat4 Mmatrix;
        attribute vec3 color;//the color of the point 
        varying vec3 vColor;
        void main(void) { //pre-built function
          gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);
          vColor=color;
        }
        </script>

    <script id="fragment-shader" type="not-javascript">
        precision mediump float; 
        varying vec3 vColor;
        void main(void) {
          gl_FragColor = vec4(vColor, 1.);
        }
        </script>
    <script type="text/javascript" src="resources/webgl-utils.js"></script>
    <script type="text/javascript" src="resources/m4.js"></script>
    <script>
        /*============= Creating a canvas ======================*/
        var canvas = document.getElementById('my_Canvas');
        gl = canvas.getContext('webgl');
        //to manage text on canvas and webgl
        // look up the text canvas.
        var textCanvas = document.getElementById("text");
        // make a 2D context for it
        var ctx = textCanvas.getContext("2d");
        /*========== Defining and storing the geometry ==========*/

        var vertices = [
            -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1,
            1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1,];
        var colors = [
            1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1,
            1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
            0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
            0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1,
            1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0,
            0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,];
        var indices = [
            0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];


        var piramide = {
            geometry: {
                vertices: [
                   1,1,-1,      1,-1,-1,       -1,-1,-1,    -1,1,-1,
                   1,1,-1,      1,-1,-1,        0,0,1,
                   -1,-1,-1,      -1,1,-1,        0,0,1,
                   -1,1,-1,      1,1,-1,        0,0,1,
                   1,-1,-1,      -1,-1,-1,        0,0,1,
                ],
                colors: [
                1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1,
                1, 0, 0, 1, 0, 1, 0, 1, 0,
                0, 0, 1, 1, 0, 1, 0, 1, 1,
                0, 0, 0, 0, 1, 1, 1, 1, 1,
                1,0, 1, 1, 1, 0, 1, 0, 0
                ],
                indices: [
                  0,1,2,    0,2,3,  4,5,6,   7,8,9,     10,11,12,  13,14,15
                ]
            },
            board_geometry: {
                vertices: [
                   1,1,-1,      1,-1,-1,       -1,-1,-1,    -1,1,-1,         0,0,1
                ],
                colors: [
                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                ],
                indices: [
                  0,1,  0,4,    1,4,    0,3,    0,4,    4,3,    3,2,    2,4,    2,1
                ]
            }
        }

        /* console.log(piramide) */

     // PYRAMIDE
        // Create and store data into vertex buffer 
        var vertex_buffer_P = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer_P);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(piramide.geometry.vertices), gl.STATIC_DRAW);
        // Create and store data into color buffer 
        var color_buffer_P = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer_P);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(piramide.geometry.colors), gl.STATIC_DRAW);
        // Create and store data into index buffer
        var index_buffer_P = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer_P);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(piramide.geometry.indices), gl.STATIC_DRAW);

        var vertex_buffer_P2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer_P2);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(piramide.board_geometry.vertices), gl.STATIC_DRAW);
        // Create and store data into color buffer 
        var color_buffer_P2 = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer_P2);
        gl.bufferData(gl.ARRAY_BUFFER,
            new Float32Array(piramide.board_geometry.colors), gl.STATIC_DRAW);
        // Create and store data into index buffer
        var index_buffer_P2 = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer_P2);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(piramide.board_geometry.indices), gl.STATIC_DRAW);

        // Creating, compiling and attach shaders to program
        var shaderprogram = webglUtils.createProgramFromScripts(gl,
            ["vertex-shader", "fragment-shader"]);

        /*======== Associating attributes to vertex shader =====*/
        var _Pmatrix = gl.getUniformLocation(shaderprogram, "Pmatrix");
        var _Vmatrix = gl.getUniformLocation(shaderprogram, "Vmatrix");
        var _Mmatrix = gl.getUniformLocation(shaderprogram, "Mmatrix");
        var _position = gl.getAttribLocation(shaderprogram, "position");
        var _color = gl.getAttribLocation(shaderprogram, "color");
        gl.useProgram(shaderprogram);

        /*==================== MATRIX ====================== */

        function degToRad(d) {
            return d * Math.PI / 180;
        }

        //usa libreria m4.js per definire proj_matrix
        var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        var zmin = 1;
        var zmax = 100;
        var fov = degToRad(40);

        var THETA = degToRad(20), PHI = degToRad(80);
        var D = 8.5;


        target = [0, 0, 1.1];
        var up = [0, 0, 1];

        var drag;
        var alpha = 0;

        /*================= Mouse events ======================*/

        var mouseDown = function (e) {
            drag = true;
            old_x = e.pageX, old_y = e.pageY;
            e.preventDefault();
            return false;
        };
        var mouseUp = function (e) {
            drag = false;
        };
        var mouseMove = function (e) {
            if (!drag) return false;
            dX = -(e.pageX - old_x) * 2 * Math.PI / canvas.width,
                dY = -(e.pageY - old_y) * 2 * Math.PI / canvas.height;
            THETA += dX;
            PHI += dY;
            old_x = e.pageX, old_y = e.pageY;
            e.preventDefault();
            render();
        };
        canvas.onmousedown = mouseDown;
        canvas.onmouseup = mouseUp;
        canvas.mouseout = mouseUp;
        canvas.onmousemove = mouseMove;
        /*=================== Drawing =================== */
        var render = function () {


            var proj_matrix = m4.perspective(fov, aspect, zmin, zmax);

            var camera = [D * Math.sin(PHI) * Math.cos(THETA),
            D * Math.sin(PHI) * Math.sin(THETA),
            D * Math.cos(PHI)];
            var view_matrix = m4.inverse(m4.lookAt(camera, target, up));

            //time_old=time;          
            gl.enable(gl.DEPTH_TEST);
            // gl.depthFunc(gl.LEQUAL); 
            gl.clearColor(1.0, 1.0, 1.0, 1);
            /*to manage text on canvas and webgl */
            // Clear the 2D canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniformMatrix4fv(_Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(_Vmatrix, false, view_matrix);
            var mo_matrix = m4.identity();
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix);

            //Piramide a facce
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer_P);
            gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_position);

            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer_P);
            gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_color);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer_P);
            gl.drawElements(gl.TRIANGLES, piramide.geometry.indices.length, gl.UNSIGNED_SHORT, 0);

            //Piramide a linee
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer_P2);
            gl.vertexAttribPointer(_position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_position);

            gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer_P2);
            gl.vertexAttribPointer(_color, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(_color);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer_P2);
            gl.drawElements(gl.LINES, piramide.board_geometry.indices.length, gl.UNSIGNED_SHORT, 0);

            /*to manage text on canvas and webgl */
            ctx.font = '18pt Calibri';
            ctx.fillStyle = 'green';
            ctx.fillText('Welcome to CG LAB', 40, 50);

            //window.requestAnimationFrame(render); 
        }
        render(0);
    </script>

</body>

</html>